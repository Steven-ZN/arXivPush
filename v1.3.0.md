## v1.3.0 更新

### 文件更新说明

#### `arxiv_fetch.py` - 核心搜索引擎 (更新详情)

##### `iterative_time_aware_search()` 函数实现

```python
def iterative_time_aware_search(cfg, target=20, max_days=7):
    """
    时间感知的迭代搜索架构
    优先抓取最新论文，动态扩展时间窗口直到满足条件

    Args:
        cfg: 配置字典
        target: 目标论文数量
        max_days: 最大搜索天数

    Returns:
        list: 按发布时间降序排列的论文列表
    """
    from datetime import datetime, timedelta
    from dateutil.tz import gettz

    tz_local = gettz(cfg.get("timezone", "America/New_York"))
    current_date = datetime.now(tz_local).date()

    collected = []
    seen_ids = set()
    time_window = 1

    # 获取搜索配置
    cats = cfg.get("categories", ["cs.AI", "cs.LG", "cs.CL", "cs.CV"])
    excludes = [e.lower() for e in cfg.get("exclude", [])]

    print(f"启动时间感知迭代搜索")
    print(f"当前日期: {current_date}")
    print(f"目标论文: {target} 篇")
    print(f"最大搜索范围: {max_days} 天")

    while len(collected) < target and time_window <= max_days:
        # 计算当前搜索窗口
        end_date = current_date - timedelta(days=time_window-1)
        start_date = current_date - timedelta(days=time_window)

        print(f"搜索窗口: {start_date} ~ {end_date}")

        try:
            # 构建时间窗口查询
            cat_query = " OR ".join([f'cat:{cat}' for cat in cats])

            # 使用arxiv API的时间过滤
            search = arxiv.Search(
                query=cat_query,
                max_results=100,
                sort_by=arxiv.SortCriterion.SubmittedDate,
                sort_order=arxiv.SortOrder.Descending,
            )

            # 获取结果并过滤
            batch_new_papers = []
            for r in arxiv.Client().results(search):
                # 转换为本地时区
                pub_local = r.published.astimezone(tz_local)
                pub_date = pub_local.date()

                # 检查是否在当前搜索窗口内
                if not (start_date <= pub_date <= end_date):
                    continue

                # 去重（避免不同版本的同一论文）
                base_id = r.get_short_id().split('v')[0]
                if base_id in seen_ids:
                    continue
                seen_ids.add(base_id)

                # 过滤排除词
                title = r.title.lower()
                abstract = (r.summary or '').lower()
                if any(e and (e in title or e in abstract) for e in excludes):
                    continue

                batch_new_papers.append(r)

            # 添加到收集列表
            collected.extend(batch_new_papers)

            print(f"窗口 {time_window}: 新增 {len(batch_new_papers)} 篇, 累计 {len(collected)} 篇")

            # 检查是否达到目标
            if len(collected) >= target:
                print(f"已达到目标 {target} 篇论文!")
                break

        except Exception as e:
            print(f"窗口 {time_window} 搜索失败: {e}")

        # 动态扩展时间窗口
        time_window += 1

        # 防止过于频繁的API调用
        import time
        time.sleep(0.5)

    # 最终排序和截取
    collected.sort(key=lambda x: x.published, reverse=True)
    final_results = collected[:target]

    print("迭代搜索完成!")
    print(f"搜索窗口数: {time_window - 1}")
    print(f"总论文数: {len(collected)}")
    print(f"最终选取: {len(final_results)} 篇")

    if final_results:
        latest = final_results[0].published.astimezone(tz_local)
        oldest = final_results[-1].published.astimezone(tz_local)
        print(f"时间范围: {oldest.strftime('%Y-%m-%d')} ~ {latest.strftime('%Y-%m-%d')}")

    return final_results
```

#### `arxiv-cli.py` Ollama 集成功能详情

##### 自动 Ollama 服务管理实现

```python
# 在启动时自动检查和启动 Ollama 服务
def cmd_start(self):
    # 检查并启动Ollama服务
    print("检查 Ollama 服务...")
    ollama_manager = create_ollama_manager(CFG)

    if not ollama_manager.start_service(auto_start=True):
        print("Ollama 服务启动失败")
        print("arXiv Push 需要 Ollama 服务来生成摘要")
        print("请手动检查 Ollama 安装和配置")
        return

    print("Ollama 服务就绪")

    # 启动服务
    try:
        import subprocess
        # 使用nohup在后台启动服务
        process = subprocess.Popen([
            'nohup', 'python3', 'bot.py'
        ], stdout=open('bot_output.log', 'w'),
           stderr=subprocess.STDOUT)

        # 等待进程启动
        import time
        time.sleep(2)

        # 验证进程是否成功启动
        if process.poll() is None:  # 进程还在运行
            print("arXiv Push 服务启动成功")

            # 更新状态
            self.status["running"] = True
            self.status["start_time"] = datetime.now().isoformat()
            self.save_status()

            # 显示配置信息
            print(f"报送时间: {', '.join(CFG.get('report_times', []))} ({TZNAME})")
            print(f"时间窗口: {WINDOW_H} 小时")
            print(f"Ollama 模型: {CFG.get('ollama', {}).get('model', 'qwen2.5:7b')}")
            print(f"日志文件: bot_output.log")
            print(f"使用 'arxiv status' 查看服务状态")
            print(f"使用 'arxiv smi' 查看实时监控")

        else:
            print("服务启动失败")
            print("请检查日志文件: bot_output.log")

    except Exception as e:
        print(f"启动失败: {str(e)}")
        print("请检查 Python 环境和依赖包")
```

### 系统管理命令完整列表

#### 服务控制命令

```bash
arxiv start     # 启动服务 (包含 Ollama)
arxiv stop      # 停止服务
arxiv restart   # 重启服务
arxiv status    # 查看状态
arxiv smi       # 实时监控
```

#### Ollama 服务管理

```bash
arxiv-ollama          # 查看状态
arxiv-ollama start    # 启动服务
arxiv-ollama stop     # 停止服务
arxiv-ollama restart  # 重启服务
arxiv-ollama test     # 测试服务
arxiv-ollama status   # 详细状态
```

#### 报告管理命令

```bash
arxiv report am    # 生成早报
arxiv report pm    # 生成晚报
arxiv rn          # 智能判断早报/晚报
arxiv rn am       # 强制生成早报
arxiv rn pm       # 强制生成晚报
```

#### 配置管理命令

```bash
arxiv config get              # 查看所有配置
arxiv config get categories   # 查看分类配置
arxiv config get ollama       # 查看Ollama配置
arxiv config set digest_max_items 25  # 修改配置
```

#### 关键词管理命令 (完全自定义)

```bash
arxiv keywords                    # 显示当前关键词配置
arxiv keywords clear              # 清空所有关键词配置
arxiv keywords add-or "word1,word2"    # 添加任意匹配关键词
arxiv keywords add-and "word1,word2"   # 添加全部匹配关键词
arxiv keywords exclude "word1,word2"   # 添加排除关键词
arxiv keywords set-default        # 设置默认关键词配置
arxiv keywords set-ai             # 设置AI领域关键词配置
arxiv keywords set-cv             # 设置计算机视觉关键词配置
```

#### 其他管理命令

```bash
arxiv logs [lines=10]    # 查看日志
arxiv help              # 显示帮助
```

### 编程接口高级用法

#### 自定义搜索配置

```python
import arxiv_fetch
from datetime import datetime
from dateutil.tz import gettz

# 完全自定义的配置
cfg = {
    # 自定义 arXiv 分类 (任何支持的分类)
    'categories': [
        'cs.AI',      # 人工智能
        'cs.LG',      # 机器学习
        'cs.CL',      # 计算语言学
        'cs.CV',      # 计算机视觉
        'cs.RO',      # 机器人学
        'stat.ML'     # 统计机器学习
    ],

    # 自定义目标数量
    'digest_max_items': 25,

    # 自定义排除关键词
    'exclude': [
        'survey', 'review', 'perspective', 'tutorial'
    ],

    # 自定义时区
    'timezone': 'Asia/Shanghai',

    # 自定义查询逻辑
    'queries': [
        {'any': ['machine learning', 'deep learning', 'neural network']},
        {'all': ['transformer', 'attention']},
        {'any': ['computer vision', 'image recognition', 'object detection']}
    ]
}

now_local = datetime.now(gettz('Asia/Shanghai'))

# 执行搜索
papers = arxiv_fetch.fetch_window(cfg, None, now_local)
print(f"获得 {len(papers)} 篇最新论文")

# 遍历论文信息
for i, paper in enumerate(papers, 1):
    pub_time = paper.published.astimezone(gettz('Asia/Shanghai'))
    print(f"{i}. {paper.title[:80]}...")
    print(f"   发布时间: {pub_time.strftime('%Y-%m-%d %H:%M')}")
    print(f"   分类: {paper.primary_category}")
    print(f"   作者数: {len(paper.authors)}")
    print(f"   ID: {paper.get_short_id()}")
    print()
```

#### 直接调用时间感知搜索

```python
# 高级搜索配置
papers = arxiv_fetch.iterative_time_aware_search(
    cfg=cfg,
    target=30,        # 自定义目标数量
    max_days=14       # 自定义最大搜索天数
)

# 数据打包
data = arxiv_fetch.pack_papers(cfg, papers)
print(f"打包数据: {len(data)} 篇论文")

# 查看打包数据结构
for item in data[:3]:  # 显示前3篇
    print(f"标题: {item['title']}")
    print(f"作者: {', '.join(item['authors'][:3])}...")
    print(f"链接: {item['link']}")
    print(f"摘要: {item['abstract'][:100]}...")
    print()
```




